local get_nodes
local get_colors
local set_invisible
local setup_druid

local nodes

-- Change the checkbox and set fullscreen or not
local function checkbox_change(self, value)
	if value == true then

		-- Show the checkbox
		gui.set_visible(gui.get_node("checkbox/back"), true)
		gui.set_visible(gui.get_node("checkbox/check"), true)
		-- Set in fullscreen
		defos.set_window_size(0, 0, max_width, max_height)
		defos.set_view_size(0, 0, max_width, max_height)

		defos.set_fullscreen(true)
		-- Hide the blue hover on resolution
		gui.set_enabled(gui.get_node("hover_options_resolution"), false)
		fullscreen = true

		gui.set_text(gui.get_node("text_options_resolution_active"), max_width.."x"..max_height)
	end

	if value == false then
		-- Show the checkbox
		gui.set_visible(gui.get_node("checkbox/back"), true)
		gui.set_visible(gui.get_node("checkbox/check"), false)

		-- Disable fullscreen
		defos.set_fullscreen(false)
		defos.set_window_size(0, 0, actual_width, actual_height)
		defos.set_view_size(0, 0, actual_width, actual_height)

		-- Show the blue hover on resolution
		gui.set_enabled(gui.get_node("hover_options_resolution"), true)
		gui.set_text(gui.get_node("text_options_resolution_active"), actual_width.."x"..actual_height)
		fullscreen = false
	end

end

-- Create options elements
local function setup_druid(self)

	-- Register the new elements
	checkbox = require("druid.extended.checkbox")
	druid.register("checkbox", checkbox)

	slider = require("druid.extended.slider")
	druid.register("slider", slider)


	-- Checkbox for fullscreen
	self.druid = druid.new(self)
	checkbox_fullscreen = self.druid:new_checkbox("checkbox/back", checkbox_change)

	-- Change here with the saved value
	checkbox_fullscreen:set_state(false)
	fullscreen = false


	-- Slider for volume
	slider_music = self.druid:new_slider("slider_music/pin", vmath.vector3(95, 0, 0), function(_, value)
		gui.set_text(gui.get_node("slider_music/text"), math.ceil(value * 100) .. "%")
		sound.set_group_gain("music", value)
	end)

	slider_music:set(1)
	slider_music:set_input_node("slider_music/input_zone")


	-- Slider for clicks
	slider_click = self.druid:new_slider("slider_click/pin", vmath.vector3(95, 0, 0), function(_, value)
		gui.set_text(gui.get_node("slider_click/text"), math.ceil(value * 100) .. "%")
		sound.set_group_gain("sound", value)
	end)

	slider_click:set(1)
	slider_click:set_input_node("slider_click/input_zone")

end

function get_nodes()
	-- Initiate table
	for i = 1, 8 do
		nodes[i] = {}
	end
	
	resolution_text = gui.get_node("text_options_resolution")
	resolution_active_text = gui.get_node("text_options_resolution_active")
	fullscreen_text = gui.get_node("text_options_fullscreen")
	music_text = gui.get_node("text_options_sound_music")
	click_text= gui.get_node("text_options_sound_click")
	language_text = gui.get_node("text_options_language")

	resolution_hover = gui.get_node("hover_options_resolution")
	resolution_active_hover = gui.get_node("hover_options_resolution_active")
	fullscreen_hover = gui.get_node("hover_options_fullscreen")
	music_hover = gui.get_node("hover_options_sound_music")
	click_hover = gui.get_node("hover_options_sound_click")
	language_hover = gui.get_node("hover_options_language")

	checkbox_fullscreen = gui.get_node("checkbox/back")
	checkbox_fullscreen2 = gui.get_node("checkbox/back1")

	slider_music = gui.get_node("slider_music/root")
	slider_click = gui.get_node("slider_click/root")

	nodes[1][1] = resolution_text
	nodes[1][2] = resolution_hover
	nodes[2][1] = resolution_active_text
	nodes[2][2] = resolution_active_hover
	nodes[3][1] = fullscreen_text
	nodes[3][2] = fullscreen_hover
	nodes[4][1] = music_text
	nodes[4][2] = music_hover
	nodes[5][1] = click_text
	nodes[5][2] = click_hover
	nodes[6][1] = language_text
	nodes[6][2] = language_hover
	nodes[7][1] = checkbox_fullscreen
	nodes[7][2] = checkbox_fullscreen2
	nodes[8][1] = slider_music
	nodes[8][2] = slider_click
end

function get_colors()
	color_hover = gui.get_color(resolution_hover)
end

function set_invisible()

	for i = 1,#nodes do
		for j = 1,2 do
			gui.set_color(nodes[i][j], color_invisible)
		end
	end
end

function init(self)
	nodes = {}
	hover_activated = 0
	
	get_nodes()
	get_colors()
	set_invisible()

	setup_druid(self)
end

-- Launch the submenu
function launch_options(self)
	for i=1, #nodes do
		button_anim_fadein(nodes[i][1], 0, color_visible)
	end

	for i=1, #nodes do
		if i ~= 2 then
			button_anim_fadein(nodes[i][2], 0, color_hover)
		end
	end

	if fullscreen == true then
		gui.set_enabled(node_hover_options_resolution, false)
	end

	local modes, modes1, width, height = defos.get_window_size()
	gui.set_text(resolution_active_text, actual_width.."x"..actual_height)
end

-- Quit the submenu
function quit_options(self)
	for i=1, #nodes do
		button_anim_fadeout(nodes[i][1], 0)
	end

	for i=1, #nodes do
		button_anim_fadein(nodes[i][2], 0, color_invisible)
	end
end

-- When a message is received
function on_message(self, message_id, message, sender)
	self.druid:on_message(message_id, message, sender)
	
	if message_id == hash("show_mainmenu_options") then
		msg.post(".", "acquire_input_focus")
		hover_activated = 1
		msg.post("mainmenu_background", "activate_shade")
		launch_options()
	end

	if message_id == hash("hide_mainmenu_options") then
		hover_activated = 0
		msg.post("mainmenu_background", "deactivate_shade")
		quit_options()
	end
end

-- On mouse input
function on_input(self, action_id, action)
	-- Activate hover
	if action_id == nil and hover_activated == 1 then

		-- Button resolution active
		if gui.pick_node(resolution_active_text, action.x, action.y) then
			gui.set_color(resolution_active_hover, vmath.vector4(color_hover))
		else
			gui.set_color(resolution_active_hover, color_invisible)
		end

	end

	-- All actions on click
	if(action_id == hash("touch") and action.pressed == true) then
		-- Button resolution
		if(gui.pick_node(resolution_active_hover, action.x, action.y)) and fullscreen == false then

			local next_resolution_index = resolution_index + 1

			-- If index is at max
			if(next_resolution_index > resolution_length) then
				next_resolution_index = 1
			end

			-- If resolution is higher than monitor max resolution
			if widths[next_resolution_index] > max_width then
				while widths[next_resolution_index] > max_width do
					next_resolution_index = next_resolution_index + 1
				end
			end

			-- Set the new resolution
			resolution_index = next_resolution_index

			actual_width = widths[next_resolution_index]
			actual_height = heights[next_resolution_index]

			defos.set_window_size(0, 0, actual_width, actual_height)
			defos.set_view_size(0, 0, actual_width, actual_height)
			gui.set_text(resolution_active_text, actual_width.."x"..actual_height)
		end
	end

	return self.druid:on_input(action_id, action)
end

function on_reload(self)
end
